}
imb::keyed_registry< imb::var_location, ${TYPE} > * descriptor_registry_${TYPE}_find_impl( imb::descriptor_registry_map_spec& map, const char* name ){
	auto ptr = map.find_registry < ${TYPE} > ( std::string{name} );
	return ptr;
}

extern "C" {

int descriptor_registry_${TYPE}_create( struct descriptor_registry_${TYPE}* registry, const char* name, struct descriptor_registry_ctx* ctx){
	assert(ctx);
	if(!ctx){
		return -1;
	}

	assert(registry);
	if(!registry){
		return -1;
	}
	auto map = reinterpret_cast<imb::descriptor_registry_map_spec*>(ctx->internal);

	map->add_registry< ${TYPE} > ( std::string{name} );

	auto internal = map->find_registry< ${TYPE} > ( std::string{name} );
	if(!internal){
		return -1;
	}

	registry->ctx = ctx;

	size_t name_size = strlen(name);
	char *name_ptr = static_cast<char*>(malloc(sizeof(char)*(name_size+1)));
	strncpy(name_ptr, name, name_size+1);
	
	registry->name = name_ptr;

	return 0;
}

void descriptor_registry_${TYPE}_destroy( struct descriptor_registry_${TYPE}* registry ){
	assert(registry);

	if(!registry){
		return;
	}

	assert(registry->ctx);
	if(!registry->ctx){
		return;
	}

	assert(registry->name);
	if(!registry->name){
		return;
	}

	auto map = reinterpret_cast<imb::descriptor_registry_map_spec*>(registry->ctx->internal);
	assert(map);
	if(!map){
		return;
	}

	/// @todo implement
	// map->remove(name);

	free(registry->name);
}

size_t descriptor_registry_${TYPE}_add_var( struct descriptor_registry_${TYPE}* registry, ${TYPE} value ){
	assert(registry);
	if(!registry){
		return std::numeric_limits<size_t>::max();
	}

	assert(registry->ctx);
	if(!registry->ctx){
		return std::numeric_limits<size_t>::max();
	}
	auto map = reinterpret_cast<imb::descriptor_registry_map_spec*>(registry->ctx->internal);

	auto ptr = descriptor_registry_${TYPE}_find_impl(*map, registry->name);
	assert(ptr);
	if(!ptr){
		return std::numeric_limits<size_t>::max();
	}

	static size_t i = 0;

	return ptr->add_var(imb::var_location{static_cast<int32_t>(i++), 1,1,1}, value);
}

int var_collection_${TYPE}_create ( struct var_collection_${TYPE}* collection, struct descriptor_registry_${TYPE}* registry ){
	assert( collection && registry && registry->ctx );
	if( ! ( collection && registry && registry->ctx ) ){
		return -1;
	}

	auto map = reinterpret_cast<imb::descriptor_registry_map_spec*>(registry->ctx->internal);
	auto reg = descriptor_registry_${TYPE}_find_impl ( *map, registry->name );

	collection->internal = new (std::nothrow) imb::keyed_var_collection< imb::var_location, ${TYPE} >(reg->internal_registry(), reg->internal_registry_index());

	if(! collection->internal ){
		return -1;
	}

	return 0;
}

int var_collection_${TYPE}_create_global ( struct var_collection_${TYPE}* collection, struct descriptor_registry_${TYPE}* registry ) {
	assert( collection && registry && registry->ctx );
	if ( ! ( collection && registry && registry->ctx ) ){
		return -1;
	}

	auto map = reinterpret_cast<imb::descriptor_registry_map_spec*>(registry->ctx->internal);
	auto reg = descriptor_registry_${TYPE}_find_impl ( *map, registry->name );

	auto var_ptr = new (std::nothrow) imb::keyed_var_collection< imb::var_location, ${TYPE} >(reg->internal_registry(), reg->internal_registry_index());
	collection->internal = var_ptr;

	(*var_ptr) = std::move(reg->global_keyed_collection());
	
	if(! collection->internal ){
		return -1;
	}

	return 0;
}

void var_collection_${TYPE}_destroy ( struct var_collection_${TYPE}* collection ){
	assert(collection && collection->internal);
	if(! ( collection && collection->internal ) ){
		return;
	}
	delete reinterpret_cast< imb::keyed_var_collection< imb::var_location, ${TYPE} >* > ( collection->internal );
}

void var_collection_${TYPE}_for_each ( struct var_collection_${TYPE}* collection, void (*func)( const struct var_descriptor*, ${TYPE} ) ) {
	assert(collection && collection->internal);
	if(! ( collection && collection->internal ) ){
		return;
	}
	auto ptr = reinterpret_cast< imb::keyed_var_collection< imb::var_location, ${TYPE} >* >( collection->internal );

	ptr->for_each([&](const imb::var_location& first, ${TYPE} second){
		struct var_descriptor desc;
		
		desc.name = "";
		desc.jg = first.jg;
		desc.hgrid_id = first.hgrid_id;
		desc.vgrid_id = first.vgrid_id;
		desc.time_id = first.time_id;

		func(&desc, second);
	});
}

